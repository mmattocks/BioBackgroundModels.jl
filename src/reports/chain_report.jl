struct Chain_Report
    id::Chain_ID
    final_hmm::HMM
    test_lh::AbstractFloat
    naive_lh::AbstractFloat
    final_delta::AbstractFloat
    state_run_lengths::AbstractVector{AbstractFloat}
    convergence_values::Chains
    convergence_diagnostic::ChainDataFrame
    converged::Bool
end

function Base.show(io::IO, report::Chain_Report)
    nominal_dict=Dict(0=>"th",1=>"st",2=>"nd",3=>"rd",4=>"th",5=>"th")
    haskey(nominal_dict,report.id.order) ? (nom_str=nominal_dict[report.id.order]) : (nom_str="th")
    printstyled(stdout, "HMM EM Chain Results\n"; bold=true)
    println("$(report.id.K)-state, $(report.id.order)$nom_str order HMM")
    println("Trained on observation set \"$(report.id.obs_id)\"")
    report.test_lh > report.naive_lh ? (lh_str="greater"; lh_color=:green) : (lh_str="less"; lh_color=:red)
    printstyled("Test logP(O|θ): $(report.test_lh), $lh_str than the naive model's $(report.naive_lh)\n"; color=lh_color)
    println("Replicate $(report.id.replicate)")
    report.converged ? println("Converged with final step δ $(report.final_delta)") : println("Failed to converge!")
    println(" ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶")
    println("Last θ:")
    show(report.final_hmm)
    println("State Mean Feature Length (bp)")
    for i in 1:length(report.state_run_lengths)
        println("K$i: $(report.state_run_lengths[i].*float(report.id.order+1))")
    end
    println(" ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶ ̶̶ ̶ ̶ ̶")
    lh_vec=Vector([report.convergence_values["logP(O|θ)"].data...])

    lh_plot=lineplot(lh_vec;title="Chain likelihood evolution", xlabel="Training iterate", xlim=(0,length(lh_vec)), ylim= (floor(minimum(lh_vec),sigdigits=2),0), name="logP(O|θ)")
    lineplot!(lh_plot,[report.naive_lh for i in 1:length(lh_vec)], color=:magenta,name="naive")
    show(lh_plot)
    println("\n")

    k1vec=Vector([report.convergence_values["K1"].data...])
    k_plot=lineplot(k1vec, title="State p(Auto) evolution", xlabel="Training iterate", ylabel="prob", name="K1",ylim=(0,1),xlim=(0,length(k1vec)))
    for k in 2:report.id.K
        kvec=Vector([report.convergence_values["K$k"].data...])
        lineplot!(k_plot,kvec,name="K$k")
    end
    show(k_plot)
    println()

    printstyled("\nConvergence Diagnostics\n",bold=true)
    if report.convergence_diagnostic.name != "short"
        all(Bool.(report.convergence_diagnostic.nt.stationarity)) && all(Bool.(report.convergence_diagnostic.nt.test)) ? printstyled("Likelihood and autotransition probabilites converged and passing tests.\n", color=:green) : printstyled("Not all parameters converged or passing tests!\n",color=:red)
        display(report.convergence_diagnostic)
    else
        printstyled("Convergence diagnostics unavailable for chains <10 steps!\n", color=:yellow)
    end
end
    
function latex_report(report::Chain_Report)

end

function report_chains(chains::Dict{Chain_ID,Vector{EM_step}}, test_sets::Dict{String,Vector{LongSequence{DNAAlphabet{2}}}}; naive_hmm=HMM(ones(1,1),[Categorical(4)]))
    job_ids=[id for (id,chain) in chains] # make list of chain_ids
    partitions=unique([id.obs_id for id in job_ids]) #get list of unique partitions represented among chain_ids
    naive_order = Integer(log(4,length(naive_hmm.D[1].support))-1)
    for partition in partitions #check that all partitions are available for testing and make sure codes for naive hmm are generated by adding job_ids
        !(partition in keys(test_sets)) && throw(ArgumentError("Observation set $partition required by chains for testing not present in test sets!"))
        push!(job_ids, Chain_ID(partition,length(naive_hmm.π0),naive_order, 1))
    end

    code_dict=code_job_obs(job_ids, test_sets) #code all the obs sets that are necessary ot perform our tests
    naive_lhs=Dict{String,Float64}() #construct dict of naive likelihoods for all partitions to be tested prior to individual tests
    @showprogress 1 "Testing naive hmm..." for ((partition,order),obs_set) in code_dict
        order==naive_order && (naive_lhs[partition]=obs_lh_given_hmm(code_dict[(partition,naive_order)],naive_hmm))
    end

    reports=Dict{Chain_ID,Chain_Report}()
    @showprogress 1 "Testing chains..." for (id, chain) in chains
        chains_array=zeros(length(chain),1+id.K)
        for (n,step) in enumerate(chain)
            chains_array[n,1]=step.log_p
            chains_array[n,2:end]=get_diagonal_array(step.hmm)
        end
        convergence_values=Chains(chains_array,["logP(O|θ)", ["K"*string(i) for i in 1:id.K]...])
        length(chain)>=10 ? (convergence_diagnostic=heideldiag(convergence_values)[1]) : (convergence_diagnostic=ChainDataFrame("short",(;:a=>[1.])))
        id.K > 1 ? (mean_run_lengths=sim_run_lengths(get_diagonal_array(chain[end].hmm),1000)) : (mean_run_lengths=[Inf])
        test_lh=obs_lh_given_hmm(code_dict[(id.obs_id,id.order)], chain[end].hmm)
        reports[id]=Chain_Report(id, chain[end].hmm, test_lh, naive_lhs[id.obs_id], chain[end].delta, mean_run_lengths, convergence_values, convergence_diagnostic, chain[end].converged)
    end

    return reports
end

function get_diagonal_array(hmm::HMM)
    k = length(hmm.π0)
    diagonal = zeros(k)
    @inbounds for i in 1:k
        diagonal[i] = hmm.π[i,i]
    end
    return diagonal
end

#function to simulate run lengths for vector of diagonal values
function sim_run_lengths(diagonal_value::AbstractArray, samples::Integer)
    mean_run_lengths = zeros(length(diagonal_value))
    for (i, value) in enumerate(diagonal_value)
        if value == 0.
            mean_run_lengths[i]=0.
        elseif value ==1.
            mean_run_lengths[i]=Inf
        else
            runlengths = zeros(Integer, samples)
            for s in 1:samples
                run = true
                runlength = 0
                while run
                    runlength += 1
                    if rand(1)[1] > value
                        run = false
                    end
                end
                runlengths[s] = runlength
            end
            mean_run_lengths[i] = mean(runlengths)
        end
    end
    return mean_run_lengths
end